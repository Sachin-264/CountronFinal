import 'dart:typed_data';
import 'package:flutter/material.dart';
import 'package:iconsax_flutter/iconsax_flutter.dart';
import 'package:intl/intl.dart';
import 'package:provider/provider.dart';

import '../../theme/client_theme.dart';
import '../Download/download.dart';
import 'channel_data_model.dart';
import '../../ClinetService/setting_api_service.dart';
import '../../ClinetService/export_service.dart';
import '../../provider/client_provider.dart';

class DataExportScreen extends StatefulWidget {
  final int deviceRecNo;
  final List<ChannelDataPoint> passedData;
  final List<dynamic> passedChannels;
  final DateTime startDate;
  final DateTime endDate;
  final Uint8List? graphImage;

  const DataExportScreen({
    super.key,
    required this.deviceRecNo,
    required this.passedData,
    required this.passedChannels,
    required this.startDate,
    required this.endDate,
    this.graphImage,
  });

  @override
  State<DataExportScreen> createState() => _DataExportScreenState();
}

class _DataExportScreenState extends State<DataExportScreen> {
  final SettingsApiService _settingsService = SettingsApiService();
  final ExportService _exportService = ExportService();

  bool _isLoadingSettings = true;
  bool _isGenerating = false;
  String _pdfOrientation = 'Portrait';

  late DateTime _currentStartDate;
  late DateTime _currentEndDate;

  Map<String, dynamic>? _deviceSettings;

  final TextEditingController _granularityController = TextEditingController(text: "0");
  final List<TextEditingController> _headerControllers = List.generate(4, (_) => TextEditingController());
  final List<TextEditingController> _footerControllers = List.generate(4, (_) => TextEditingController());

  @override
  void initState() {
    super.initState();
    _currentStartDate = widget.startDate;
    _currentEndDate = widget.endDate;
    _fetchSettings();
  }

  Future<void> _fetchSettings() async {
    final provider = Provider.of<ClientProvider>(context, listen: false);
    int recNo = provider.selectedDeviceRecNo ?? widget.deviceRecNo;

    final data = await _settingsService.fetchSettings(recNo);
    if (mounted) {
      setState(() {
        _deviceSettings = data;
        _isLoadingSettings = false;
        if (data != null && data['ClientCompanyName'] != null && _headerControllers[0].text.isEmpty) {
          _headerControllers[0].text = "Report generated by ${data['ClientCompanyName']}";
        }
      });
    }
  }

  Future<void> _pickDateTime(bool isStart) async {
    final initialDate = isStart ? _currentStartDate : _currentEndDate;

    final DateTime? pickedDate = await showDatePicker(
      context: context,
      initialDate: initialDate,
      firstDate: DateTime(2020),
      lastDate: DateTime.now().add(const Duration(days: 365)),
      builder: (ctx, child) => Theme(
        data: ThemeData.light().copyWith(colorScheme: ColorScheme.light(primary: ClientTheme.primaryColor)),
        child: child!,
      ),
    );

    if (pickedDate == null) return;
    if (!mounted) return;

    final TimeOfDay? pickedTime = await showTimePicker(
      context: context,
      initialTime: TimeOfDay.fromDateTime(initialDate),
      builder: (ctx, child) => Theme(
        data: ThemeData.light().copyWith(colorScheme: ColorScheme.light(primary: ClientTheme.primaryColor)),
        child: child!,
      ),
    );

    if (pickedTime == null) return;

    setState(() {
      final newDateTime = DateTime(
        pickedDate.year,
        pickedDate.month,
        pickedDate.day,
        pickedTime.hour,
        pickedTime.minute,
      );

      if (isStart) {
        if (newDateTime.isAfter(_currentEndDate)) {
          ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("Start time cannot be after End time")));
          return;
        }
        _currentStartDate = newDateTime;
      } else {
        if (newDateTime.isBefore(_currentStartDate)) {
          ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("End time cannot be before Start time")));
          return;
        }
        _currentEndDate = newDateTime;
      }
    });
  }

  void _editBranding() {
    final nameCtrl = TextEditingController(text: _deviceSettings?['ClientCompanyName'] ?? '');
    final addrCtrl = TextEditingController(text: _deviceSettings?['ClientAddress'] ?? '');

    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text("Edit Branding Details"),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextField(controller: nameCtrl, decoration: const InputDecoration(labelText: "Company Name", border: OutlineInputBorder())),
            const SizedBox(height: 12),
            TextField(controller: addrCtrl, maxLines: 2, decoration: const InputDecoration(labelText: "Address", border: OutlineInputBorder())),
          ],
        ),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx), child: const Text("CANCEL")),
          ElevatedButton(
            onPressed: () async {
              Navigator.pop(ctx);
              setState(() => _isLoadingSettings = true);

              final provider = Provider.of<ClientProvider>(context, listen: false);
              int recNo = provider.selectedDeviceRecNo ?? widget.deviceRecNo;

              await _settingsService.saveSettings(
                  recNo: recNo,
                  companyName: nameCtrl.text,
                  address: addrCtrl.text,
                  logoPath: _deviceSettings?['Logo'] ?? ''
              );

              _fetchSettings();
            },
            child: const Text("SAVE"),
          )
        ],
      ),
    );
  }

  Future<void> _performExport(String format) async {
    if (widget.passedData.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("No data available to export.")));
      return;
    }

    setState(() => _isGenerating = true);

    try {
      int interval = int.tryParse(_granularityController.text) ?? 0;

      // --- [CRITICAL] Time Filtering Logic ---
      // This logic ensures that even if 'passedData' has extra records,
      // we ONLY take what is strictly between _currentStartDate and _currentEndDate.
      final filteredData = widget.passedData.where((point) {
        bool isAfterStart = point.dateTime.isAfter(_currentStartDate) || point.dateTime.isAtSameMomentAs(_currentStartDate);
        bool isBeforeEnd = point.dateTime.isBefore(_currentEndDate) || point.dateTime.isAtSameMomentAs(_currentEndDate);
        return isAfterStart && isBeforeEnd;
      }).toList();

      if (filteredData.isEmpty) {
        throw Exception("No records found in the selected date range (${DateFormat('HH:mm').format(_currentStartDate)} - ${DateFormat('HH:mm').format(_currentEndDate)}).");
      }

      List<ChannelDataPoint> processedData = _exportService.resampleData(filteredData, interval);

      String startStr = DateFormat('yyyyMMdd_HHmm').format(_currentStartDate);
      String endStr = DateFormat('yyyyMMdd_HHmm').format(_currentEndDate);
      String fileName = "Report_${startStr}_to_$endStr";

      Map<String, dynamic> branding = {
        'name': _deviceSettings?['ClientCompanyName'] ?? '',
        'address': _deviceSettings?['ClientAddress'] ?? '',
        'logoPath': _deviceSettings?['Logo'] ?? '',
        'orientation': _pdfOrientation,
      };

      List<String> headers = _headerControllers.map((c) => c.text).where((t) => t.isNotEmpty).toList();
      List<String> footers = _footerControllers.map((c) => c.text).where((t) => t.isNotEmpty).toList();

      String durationStr = "Period: ${DateFormat('yyyy-MM-dd HH:mm').format(_currentStartDate)} to ${DateFormat('yyyy-MM-dd HH:mm').format(_currentEndDate)}";
      String granularityStr = "Granularity: ${interval == 0 ? 'Raw Data' : '$interval Minute(s) Average'}";

      if (format == 'pdf') {
        await _exportService.generateAndSavePdf(
          data: processedData,
          channels: widget.passedChannels,
          branding: branding,
          headerLines: headers,
          footerLines: footers,
          fileName: fileName,
          reportDuration: durationStr,
          dataGranularity: granularityStr,
          graphImage: widget.graphImage,
          orientation: _pdfOrientation,
        );
      } else if (format == 'excel') {
        await _exportService.generateAndSaveExcel(
          data: processedData,
          channels: widget.passedChannels,
          branding: branding,
          fileName: fileName,
          reportDuration: durationStr,
          dataGranularity: granularityStr,
          graphImage: widget.graphImage,
        );
      } else if (format == 'csv') {
        await _exportService.generateAndSaveCSV(
          data: processedData,
          channels: widget.passedChannels,
          fileName: fileName,
          reportDuration: durationStr,
          dataGranularity: granularityStr,
        );
      } else if (format == 'doc') {
        await _exportService.generateAndSaveDOC(
          data: processedData,
          channels: widget.passedChannels,
          branding: branding,
          fileName: fileName,
          reportDuration: durationStr,
          dataGranularity: granularityStr,
          graphImage: widget.graphImage,
        );
      }

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("Export Successful! Check Downloads.")));
      }

    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text("Export Failed: $e")));
      }
    } finally {
      if (mounted) {
        setState(() => _isGenerating = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final width = MediaQuery.of(context).size.width;
    final isMobile = width < 800;

    return Scaffold(
      backgroundColor: Colors.grey[50],
      appBar: AppBar(
        title: const Text("Export Wizard"),
        elevation: 0,
        backgroundColor: Colors.white,
        foregroundColor: Colors.black,
        actions: [
          IconButton(
            icon: const Icon(Iconsax.folder_open, color: ClientTheme.primaryColor),
            tooltip: "Downloaded Files",
            onPressed: () => Navigator.push(context, MaterialPageRoute(builder: (_) => const DownloadHistoryScreen())),
          )
        ],
      ),
      body: _isLoadingSettings
          ? const Center(child: CircularProgressIndicator())
          : SingleChildScrollView(
        padding: const EdgeInsets.all(16),
        child: Column(
          children: [
            _buildDateRangeCard(isMobile),
            const SizedBox(height: 16),

            if (isMobile) ...[
              _buildBrandingCard(),
              const SizedBox(height: 16),
              _buildGranularityCard(),
            ] else
              Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Expanded(child: _buildBrandingCard()),
                  const SizedBox(width: 16),
                  Expanded(child: _buildGranularityCard()),
                ],
              ),

            const SizedBox(height: 16),
            _buildCustomTextCard(isMobile),
            const SizedBox(height: 24),
            _buildActionSection(isMobile),
            const SizedBox(height: 40),
          ],
        ),
      ),
    );
  }

  Widget _buildDateRangeCard(bool isMobile) {
    return Card(
      elevation: 0,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12), side: BorderSide(color: Colors.grey.shade300)),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Row(
              children: [
                Icon(Iconsax.calendar_edit, size: 20, color: ClientTheme.primaryColor),
                SizedBox(width: 8),
                Text("Report Period (Tap to Edit)", style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),
              ],
            ),
            const SizedBox(height: 16),
            Row(
              children: [
                Expanded(child: _buildDateTimeBox("Start Date & Time", _currentStartDate, true)),
                const SizedBox(width: 12),
                Expanded(child: _buildDateTimeBox("End Date & Time", _currentEndDate, false)),
              ],
            ),
            const SizedBox(height: 12),
            Container(
              padding: const EdgeInsets.all(8),
              decoration: BoxDecoration(color: Colors.blue.withOpacity(0.05), borderRadius: BorderRadius.circular(8)),
              child: Row(
                children: [
                  const Icon(Iconsax.info_circle, size: 16, color: Colors.blue),
                  const SizedBox(width: 8),
                  Expanded(child: Text("Filtering ${widget.passedData.length} records available.", style: const TextStyle(fontSize: 12, color: Colors.blueGrey))),
                ],
              ),
            )
          ],
        ),
      ),
    );
  }

  Widget _buildDateTimeBox(String label, DateTime dt, bool isStart) {
    return InkWell(
      onTap: () => _pickDateTime(isStart),
      borderRadius: BorderRadius.circular(10),
      child: Container(
        padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 12),
        decoration: BoxDecoration(
          border: Border.all(color: Colors.grey.shade300),
          borderRadius: BorderRadius.circular(10),
          color: Colors.white,
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(label, style: const TextStyle(fontSize: 11, color: Colors.grey, fontWeight: FontWeight.bold)),
                const Icon(Iconsax.edit, size: 14, color: ClientTheme.primaryColor),
              ],
            ),
            const SizedBox(height: 6),
            Text(DateFormat('MMM dd, yyyy').format(dt), style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 14)),
            Text(DateFormat('hh:mm a').format(dt), style: const TextStyle(fontWeight: FontWeight.w600, fontSize: 13, color: ClientTheme.primaryColor)),
          ],
        ),
      ),
    );
  }

  Widget _buildBrandingCard() {
    return Card(
      elevation: 0,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12), side: BorderSide(color: Colors.grey.shade300)),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                const Row(
                  children: [
                    Icon(Iconsax.brush_2, size: 18, color: Colors.black87),
                    SizedBox(width: 8),
                    Text("Branding", style: TextStyle(fontWeight: FontWeight.bold)),
                  ],
                ),
                IconButton(
                    icon: const Icon(Iconsax.edit_2, size: 16),
                    onPressed: _editBranding,
                    constraints: const BoxConstraints(),
                    padding: EdgeInsets.zero
                )
              ],
            ),
            const SizedBox(height: 12),
            Row(
              children: [
                Container(
                  width: 40, height: 40,
                  decoration: BoxDecoration(
                      color: Colors.grey[100], borderRadius: BorderRadius.circular(8),
                      image: _deviceSettings?['Logo'] != null
                          ? DecorationImage(image: NetworkImage("https://storage.googleapis.com/upload-images-34/images/LMS/${_deviceSettings!['Logo']}"), fit: BoxFit.cover)
                          : null
                  ),
                  child: _deviceSettings?['Logo'] == null ? const Icon(Iconsax.image, size: 20, color: Colors.grey) : null,
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(_deviceSettings?['ClientCompanyName'] ?? "Company Name", style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 13), overflow: TextOverflow.ellipsis),
                      Text(_deviceSettings?['ClientAddress'] ?? "Address", style: const TextStyle(color: Colors.grey, fontSize: 11), maxLines: 1, overflow: TextOverflow.ellipsis),
                    ],
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildGranularityCard() {
    return Card(
      elevation: 0,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12), side: BorderSide(color: Colors.grey.shade300)),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Row(
              children: [
                Icon(Iconsax.timer_1, size: 18, color: Colors.black87),
                SizedBox(width: 8),
                Text("Granularity", style: TextStyle(fontWeight: FontWeight.bold)),
              ],
            ),
            const SizedBox(height: 12),
            SizedBox(
              height: 40,
              child: TextField(
                controller: _granularityController,
                keyboardType: TextInputType.number,
                style: const TextStyle(fontSize: 13),
                decoration: InputDecoration(
                  labelText: "Interval (Minutes)",
                  labelStyle: const TextStyle(fontSize: 12),
                  floatingLabelBehavior: FloatingLabelBehavior.always,
                  hintText: "0 = Raw Data",
                  contentPadding: const EdgeInsets.symmetric(horizontal: 12, vertical: 0),
                  border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                  suffixIcon: const Icon(Iconsax.clock, size: 16),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildCustomTextCard(bool isMobile) {
    return Card(
      elevation: 0,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12), side: BorderSide(color: Colors.grey.shade300)),
      child: ExpansionTile(
        title: const Row(
          children: [
            Icon(Iconsax.text_block, size: 18, color: Colors.black87),
            SizedBox(width: 8),
            Text("Header & Footer Text", style: TextStyle(fontWeight: FontWeight.bold, fontSize: 14)),
          ],
        ),
        childrenPadding: const EdgeInsets.fromLTRB(16, 0, 16, 16),
        children: [
          const Text("Header Lines (Top of PDF)", style: TextStyle(fontSize: 12, fontWeight: FontWeight.bold, color: Colors.grey)),
          const SizedBox(height: 8),
          _buildCompactGrid(_headerControllers, isMobile),
          const SizedBox(height: 16),
          const Text("Footer Lines (Bottom of PDF)", style: TextStyle(fontSize: 12, fontWeight: FontWeight.bold, color: Colors.grey)),
          const SizedBox(height: 8),
          _buildCompactGrid(_footerControllers, isMobile),
        ],
      ),
    );
  }

  Widget _buildCompactGrid(List<TextEditingController> controllers, bool isMobile) {
    return Wrap(
      spacing: 12,
      runSpacing: 12,
      children: controllers.asMap().entries.map((e) {
        double widthPercent = isMobile ? 0.46 : 0.23;
        return FractionallySizedBox(
          widthFactor: widthPercent,
          child: SizedBox(
            height: 35,
            child: TextField(
              controller: e.value,
              style: const TextStyle(fontSize: 12),
              decoration: InputDecoration(
                hintText: "Line ${e.key + 1}",
                contentPadding: const EdgeInsets.symmetric(horizontal: 10, vertical: 0),
                border: OutlineInputBorder(borderRadius: BorderRadius.circular(6), borderSide: BorderSide(color: Colors.grey.shade300)),
                enabledBorder: OutlineInputBorder(borderRadius: BorderRadius.circular(6), borderSide: BorderSide(color: Colors.grey.shade300)),
              ),
            ),
          ),
        );
      }).toList(),
    );
  }

  Widget _buildActionSection(bool isMobile) {
    return Column(
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Text("PDF Orientation: ", style: TextStyle(fontWeight: FontWeight.bold, fontSize: 13)),
            const SizedBox(width: 8),
            ToggleButtons(
              isSelected: [_pdfOrientation == 'Portrait', _pdfOrientation == 'Landscape'],
              onPressed: (index) {
                setState(() {
                  _pdfOrientation = index == 0 ? 'Portrait' : 'Landscape';
                });
              },
              borderRadius: BorderRadius.circular(8),
              constraints: const BoxConstraints(minHeight: 32, minWidth: 80),
              children: const [
                Text("Portrait", style: TextStyle(fontSize: 12)),
                Text("Landscape", style: TextStyle(fontSize: 12)),
              ],
            ),
          ],
        ),
        const SizedBox(height: 24),
        if (_isGenerating)
          const Column(children: [CircularProgressIndicator(), SizedBox(height: 10), Text("Generating Report...")])
        else
          Wrap(
            spacing: 16.0,
            runSpacing: 16.0,
            alignment: WrapAlignment.center,
            children: [
              _buildExportBtn("PDF", Iconsax.document, Colors.red, () => _performExport('pdf')),
              _buildExportBtn("Excel", Iconsax.document_text, Colors.green, () => _performExport('excel')),
              _buildExportBtn("CSV", Iconsax.document_code, Colors.blue, () => _performExport('csv')),
              _buildExportBtn("Word", Iconsax.document_text_1, Colors.indigo, () => _performExport('doc')),
            ],
          ),
      ],
    );
  }

  Widget _buildExportBtn(String label, IconData icon, Color color, VoidCallback onTap) {
    return ElevatedButton.icon(
      onPressed: onTap,
      icon: Icon(icon, size: 18),
      label: Text(label),
      style: ElevatedButton.styleFrom(
        backgroundColor: color,
        foregroundColor: Colors.white,
        padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
        elevation: 2,
      ),
    );
  }
}